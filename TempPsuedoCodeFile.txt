[numthreads(1, 1, 1)]
void main( uint3 DTid : SV_DispatchThreadID )
{
}
/*
* layout given 
layout (binding = 0) buffer bPhysicsData
{
	// contents of buffer
};

	primitive points that will be used for simulation

	layout(points) in;
	layout(GL_POINTS or points, max_vertices = MAX_VERTICES) out;

	uniform int uPointCount;
	? pointPosition[uPointCount];
	uniform float uPointSize;
	uniform vec4 uPointLocation;
	uniform vec4 uPointColors[4];
	uniform vec4 uVelocity;

	uniform mat4 uMVP;
	uniform double uTime;

	vec4 Lerp(vec4 p0, vec4 p1, float t)
	{

	return (1.0f - t) * p0 + t * p1;
	}

	vec3 CircleCircleCollision(vec3 circle0, vec circl1, float radius0, float radius1)
	{

	if((circle1.x - circle0.x)^2 + (circle1.y - circle0.y)^2 <= (radius0 + radius1)^2
	return vec3(.5f,.5f,.5f)
	else
	return vec3(0.0f)
	}

	DrawPointAtLocation(vec4 position)
	{

	gl_Position = position
	EndPrimative();?
	glDrawArrays (GL_POINTS, 0, uPointCount);?
	}

	out vec4 vColor;

	void main()
	{
	
	float sTime = sin(float(uTime));
	float cTime = cos(float(uTime));

	for(int i = 0; i < uPointCount; i++)
	{
	vColor = uPointColors[0];
	vec3 newVelocity = CircleCircleCollision(uPointLocation, other uPointLocations, uPointSize, other uPointSize);
	vec4 position = Lerp(uPointLocation, uPointLocation + uVelocity + vec4(newVelocity, 0.0f), sTime);
	DrawPointAtLocation(position);
	}
	}